"""
STEP 3: WhatsApp + Database + AI Integration
Full bot with Gemini AI, function calling, and smart data extraction
"""

import os
import logging
import json
from datetime import datetime
from fastapi import FastAPI, Request, Response, HTTPException, Depends
from fastapi.responses import JSONResponse
import uvicorn
import requests
from dotenv import load_dotenv
from google.cloud import firestore
from google import genai
from google.genai import types

# Import admin module
import admin

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# Initialize FastAPI app
app = FastAPI(title="Step 3 - WhatsApp + Database + AI")

# Include admin router
app.include_router(admin.router)

# Environment variables
WHATSAPP_TOKEN = os.getenv("WHATSAPP_TOKEN")
VERIFY_TOKEN = os.getenv("VERIFY_TOKEN", "my_test_token_123")
WHATSAPP_PHONE_NUMBER_ID = os.getenv("WHATSAPP_PHONE_NUMBER_ID")
GEMINI_API_KEY = os.getenv("GEMINI_API_KEY")

# WhatsApp API URL
WHATSAPP_API_URL = f"https://graph.facebook.com/v18.0/{WHATSAPP_PHONE_NUMBER_ID}/messages"

# Firestore client
db = None

# Welcome message in Hebrew
WELCOME_MESSAGE = """◊©◊ú◊ï◊ù ◊ï◊ë◊®◊ï◊ö ◊î◊ë◊ê ◊ú◊ê◊§◊ú◊ô◊ß◊¶◊ô◊™ ◊î◊ò◊®◊û◊§◊ô◊ù ◊©◊ú ◊í◊ë◊®◊¢◊ù! üöó

◊ê◊ù ◊ê◊™◊î ◊û◊ó◊§◊© ◊ò◊®◊û◊§ ◊©◊ú◊ó ◊ú◊ô ◊î◊ï◊ì◊¢◊î ◊ë◊°◊í◊†◊ï◊ü:
"◊ê◊†◊ô ◊û◊ó◊§◊© ◊ò◊®◊û◊§ ◊ú◊™◊ú ◊ê◊ë◊ô◊ë ◊ë◊©◊¢◊î 12:00 ◊û◊ó◊®"

◊ê◊ù ◊ê◊™◊î ◊†◊î◊í ◊©◊®◊ï◊¶◊î ◊ú◊¢◊ñ◊ï◊®:
"◊ê◊†◊ô ◊†◊ï◊°◊¢ ◊ë◊ô◊û◊ô◊ù ◊ê-◊î ◊ú◊™◊ú ◊ê◊ë◊ô◊ë ◊ë◊©◊¢◊î 9 ◊ï◊ó◊ï◊ñ◊® ◊ë-17:30"

◊ê◊ô◊ö ◊ê◊†◊ô ◊ô◊õ◊ï◊ú ◊ú◊¢◊ñ◊ï◊® ◊ú◊ö ◊î◊ô◊ï◊ù?"""

# System prompt for Gemini
SYSTEM_PROMPT = """◊ê◊™◊î ◊¢◊ï◊ñ◊® ◊ï◊ô◊®◊ò◊ï◊ê◊ú◊ô ◊ú◊ß◊î◊ô◊ú◊™ ◊î◊ò◊®◊û◊§◊ô◊ù ◊©◊ú ◊í◊ë◊®◊¢◊ù. ◊™◊§◊ß◊ô◊ì◊ö:

1. ◊ú◊ñ◊î◊ï◊™ ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊î◊ï◊ê ◊†◊î◊í (driver) ◊ê◊ï ◊û◊ó◊§◊© ◊ò◊®◊û◊§ (hitchhiker)
2. ◊ú◊ê◊°◊ï◊£ ◊û◊ô◊ì◊¢ ◊û◊ï◊ë◊†◊î ◊ï◊ú◊©◊û◊ï◊® ◊ê◊ï◊™◊ï ◊û◊ô◊ì
3. ◊ú◊ì◊ë◊® ◊ë◊¢◊ë◊®◊ô◊™ ◊ë◊¶◊ï◊®◊î ◊ô◊ì◊ô◊ì◊ï◊™◊ô◊™ ◊ï◊ë◊®◊ï◊®◊î
4. ◊ú◊¢◊ì◊õ◊ü ◊¢◊ú ◊î◊™◊ê◊û◊ï◊™ ◊©◊†◊û◊¶◊ê◊ï (matches)!

‚ö†Ô∏è ◊ê◊ú ◊™◊©◊ú◊ó ◊î◊ï◊ì◊¢◊ï◊™ ◊ë◊®◊ï◊õ◊ô◊ù ◊î◊ë◊ê◊ô◊ù - ◊î◊û◊¢◊®◊õ◊™ ◊õ◊ë◊® ◊©◊ú◊ó◊î!

◊û◊ô◊ì◊¢ ◊†◊ì◊®◊©:
- ◊û◊ó◊§◊© ◊ò◊®◊û◊§ (hitchhiker): ◊ô◊¢◊ì + ◊™◊ê◊®◊ô◊ö/◊ñ◊û◊ü (◊ì◊ô ◊ë-1 ◊î◊ï◊ì◊¢◊î!)
- ◊†◊î◊í (driver): ◊ô◊¢◊ì + ◊ô◊û◊ô◊ù ◊ë◊©◊ë◊ï◊¢ + ◊©◊¢◊î ◊ô◊¶◊ô◊ê◊î

◊ó◊ï◊ß◊ô◊ù ◊ß◊®◊ô◊ò◊ô◊ô◊ù:
‚ö° ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊†◊™◊ü ◊ô◊¢◊ì + ◊ñ◊û◊ü/◊™◊ê◊®◊ô◊ö - ◊©◊û◊ï◊® ◊û◊ô◊ì! ◊ê◊ú ◊™◊©◊ê◊ú ◊©◊ê◊ú◊ï◊™ ◊ê◊ô◊©◊ï◊®!
‚ö° "◊û◊ó◊®" = ◊™◊ê◊®◊ô◊ö ◊©◊ú ◊û◊ó◊® (◊ó◊©◊ë ◊ú◊§◊ô ◊î◊™◊ê◊®◊ô◊ö ◊î◊†◊ï◊õ◊ó◊ô)
‚ö° "◊î◊ô◊ï◊ù" = ◊™◊ê◊®◊ô◊ö ◊©◊ú ◊î◊ô◊ï◊ù
‚ö° ◊ê◊ù ◊î◊û◊©◊™◊û◊© ◊ê◊ï◊û◊® "◊õ◊ü" - ◊ñ◊î ◊ê◊ô◊©◊ï◊®! ◊ê◊ú ◊™◊©◊ê◊ú ◊©◊ï◊ë!
‚ö° ◊†◊ß◊ï◊ì◊™ ◊î◊û◊ï◊¶◊ê ◊™◊û◊ô◊ì ◊í◊ë◊®◊¢◊ù - ◊ê◊ú ◊™◊©◊ê◊ú!
‚ö° ◊ê◊ú ◊™◊©◊ê◊ú ◊¢◊ú ◊û◊°◊§◊® ◊û◊ß◊ï◊û◊ï◊™ ◊§◊†◊ï◊ô◊ô◊ù - ◊ë◊®◊ô◊®◊™ ◊û◊ó◊ì◊ú 3
‚ö° ◊ê◊ú ◊™◊©◊ê◊ú ◊©◊ê◊ú◊ï◊™ ◊ê◊ô◊©◊ï◊® - ◊ê◊ù ◊ô◊© ◊û◊°◊§◊ô◊ß ◊û◊ô◊ì◊¢, ◊©◊û◊ï◊®!

üéØ ◊ê◊ó◊®◊ô ◊©◊û◊ô◊®◊™ ◊†◊™◊ï◊†◊ô◊ù - ◊î◊§◊ï◊†◊ß◊¶◊ô◊î ◊û◊ó◊ñ◊ô◊®◊î ◊î◊™◊ê◊û◊ï◊™:
- ◊ê◊ù matches_found > 0: ◊°◊§◊® ◊ú◊û◊©◊™◊û◊© ◊©◊û◊¶◊ê◊™ X ◊î◊™◊ê◊û◊ï◊™!
- ◊ê◊ù matches_found = 0: ◊°◊§◊® ◊©◊î◊§◊®◊ò◊ô◊ù ◊†◊©◊û◊®◊ï ◊ï◊™◊¢◊ì◊õ◊ü ◊õ◊©◊ô◊î◊ô◊ï ◊î◊™◊ê◊û◊ï◊™

◊ì◊ï◊í◊û◊ê◊ï◊™ ◊†◊õ◊ï◊†◊ï◊™:
◊û◊©◊™◊û◊©: "◊ê◊†◊ô ◊û◊ó◊§◊© ◊ò◊®◊û◊§ ◊ú◊™◊ú ◊ê◊ë◊ô◊ë ◊û◊ó◊® ◊ë-10:00"
◊ê◊™◊î: ◊ß◊®◊ê ◊ú◊§◊ï◊†◊ß◊¶◊ô◊î update_user_records ◊û◊ô◊ì ◊¢◊ù:
- role: "hitchhiker"
- destination: "◊™◊ú ◊ê◊ë◊ô◊ë"
- travel_date: "2025-01-01" (◊ê◊ù ◊î◊ô◊ï◊ù 31/12/2025)
- departure_time: "10:00"

◊ê◊ó◊®◊ô ◊î◊§◊ï◊†◊ß◊¶◊ô◊î:
- ◊ê◊ù ◊ô◊© matches: "◊û◊¶◊ï◊ô◊ü! ◊û◊¶◊ê◊™◊ô X ◊†◊î◊í◊ô◊ù ◊©◊†◊ï◊°◊¢◊ô◊ù ◊ú◊™◊ú ◊ê◊ë◊ô◊ë! üöó"
- ◊ê◊ù ◊ê◊ô◊ü: "◊î◊§◊®◊ò◊ô◊ù ◊†◊©◊û◊®◊ï! ◊ê◊¢◊ì◊õ◊ü ◊ê◊ï◊™◊ö ◊õ◊©◊ô◊î◊ô◊î ◊†◊î◊í ◊ñ◊û◊ô◊ü. üì≤"

◊û◊©◊™◊û◊©: "◊ê◊†◊ô ◊†◊ï◊°◊¢ ◊ú◊ô◊®◊ï◊©◊ú◊ô◊ù ◊ê-◊î ◊ë-9"
◊ê◊™◊î: ◊ß◊®◊ê ◊ú◊§◊ï◊†◊ß◊¶◊ô◊î ◊û◊ô◊ì ◊¢◊ù:
- role: "driver"
- destination: "◊ô◊®◊ï◊©◊ú◊ô◊ù"
- days: ["◊®◊ê◊©◊ï◊ü", "◊©◊†◊ô", "◊©◊ú◊ô◊©◊ô", "◊®◊ë◊ô◊¢◊ô", "◊ó◊û◊ô◊©◊ô"]
- departure_time: "09:00"

‚ùå ◊ê◊°◊ï◊® ◊ú◊©◊ê◊ï◊ú: "◊®◊ß ◊ú◊ï◊ï◊ì◊ê - ◊û◊ó◊® ◊ñ◊î..."
‚ùå ◊ê◊°◊ï◊® ◊ú◊©◊ê◊ï◊ú ◊§◊¢◊û◊ô◊ô◊ù ◊ê◊™ ◊ê◊ï◊™◊ï ◊ì◊ë◊®!
‚úÖ ◊©◊û◊ï◊® ◊û◊ô◊ì ◊ï◊°◊§◊® ◊ú◊û◊©◊™◊û◊© ◊©◊î◊§◊®◊ò◊ô◊ù ◊†◊©◊û◊®◊ï!

◊î◊ß◊©◊® ◊î◊†◊ï◊õ◊ó◊ô:
- ◊™◊ê◊®◊ô◊ö ◊ï◊©◊¢◊î: {current_timestamp}
- ◊ô◊ï◊ù ◊ë◊©◊ë◊ï◊¢: {current_day_of_week}


"""

# Function calling schema - will be created after genai.configure()
def get_function_tool():
    """Get the function calling tool for Gemini"""
    return types.Tool(
        function_declarations=[
            types.FunctionDeclaration(
                name="update_user_records",
                description="Update user role and structured data in the database. Use this when you have collected enough information about the user.",
                parameters=types.Schema(
                    type=types.Type.OBJECT,
                    properties={
                        "role": types.Schema(
                            type=types.Type.STRING,
                            description="User's role - either 'driver' or 'hitchhiker'",
                            enum=["driver", "hitchhiker"]
                        ),
                    "origin": types.Schema(
                        type=types.Type.STRING,
                        description="Starting location - always '◊í◊ë◊®◊¢◊ù' (default)"
                    ),
                        "destination": types.Schema(
                            type=types.Type.STRING,
                            description="Destination location (e.g., '◊™◊ú ◊ê◊ë◊ô◊ë', '◊ó◊ô◊§◊î')"
                        ),
                        "days": types.Schema(
                            type=types.Type.ARRAY,
                            description="Days of the week (for drivers)",
                            items=types.Schema(type=types.Type.STRING)
                        ),
                        "departure_time": types.Schema(
                            type=types.Type.STRING,
                            description="Departure time - e.g., '09:00', '17:30'"
                        ),
                        "return_time": types.Schema(
                            type=types.Type.STRING,
                            description="Return time (for drivers who make round trips)"
                        ),
                    "available_seats": types.Schema(
                        type=types.Type.INTEGER,
                        description="Number of available seats (for drivers) - optional, default to 3"
                    ),
                        "travel_date": types.Schema(
                            type=types.Type.STRING,
                            description="Specific travel date for hitchhikers"
                        ),
                        "flexibility": types.Schema(
                            type=types.Type.STRING,
                            description="Time flexibility for hitchhikers"
                        ),
                        "notes": types.Schema(
                            type=types.Type.STRING,
                            description="Additional notes or preferences"
                        )
                    },
                    required=["role", "destination"]
                )
            )
        ]
    )


@app.on_event("startup")
async def startup_event():
    """Initialize services on startup"""
    global db
    
    # Initialize Firestore
    try:
        project_id = os.getenv("GOOGLE_CLOUD_PROJECT")
        if project_id:
            db = firestore.Client(project=project_id)
            logger.info(f"‚úÖ Firestore initialized for project: {project_id}")
        else:
            db = firestore.Client()
            logger.info("‚úÖ Firestore initialized successfully")
    except Exception as e:
        logger.error(f"‚ùå Failed to initialize Firestore: {str(e)}")
        logger.warning("‚ö†Ô∏è  Continuing without database...")
    
    # Initialize Gemini - new SDK uses client object
    if GEMINI_API_KEY:
        logger.info("‚úÖ Gemini API key configured")
    else:
        logger.warning("‚ö†Ô∏è  GEMINI_API_KEY not set - AI features disabled")
    
    # Log admin status
    logger.info(f"üîß Admin status: {admin.get_admin_status_message()}")


@app.get("/")
async def root():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "step": "3 - WhatsApp + Database + AI",
        "database": "connected" if db else "disconnected",
        "ai": "enabled" if GEMINI_API_KEY else "disabled",
        "message": "Full AI-powered hitchhiking bot!"
    }


@app.get("/webhook")
async def verify_webhook(request: Request):
    """Webhook verification endpoint for WhatsApp"""
    mode = request.query_params.get("hub.mode")
    token = request.query_params.get("hub.verify_token")
    challenge = request.query_params.get("hub.challenge")
    
    logger.info(f"Webhook verification request - mode: {mode}")
    
    if mode == "subscribe" and token == VERIFY_TOKEN:
        logger.info("‚úÖ Webhook verified successfully!")
        return Response(content=challenge, media_type="text/plain")
    
    logger.warning("‚ùå Webhook verification failed")
    raise HTTPException(status_code=403, detail="Verification failed")


@app.post("/webhook")
async def handle_webhook(request: Request):
    """Handle incoming WhatsApp messages with AI processing"""
    try:
        body = await request.json()
        logger.info(f"üì• Received webhook")
        
        if not body.get("entry"):
            return JSONResponse(content={"status": "ok"})
        
        for entry in body["entry"]:
            changes = entry.get("changes", [])
            
            for change in changes:
                value = change.get("value", {})
                
                if "messages" not in value:
                    continue
                
                messages = value["messages"]
                
                for message in messages:
                    from_number = message.get("from")
                    message_type = message.get("type")
                    
                    logger.info(f"üì® Message from: {from_number}, type: {message_type}")
                    
                    if message_type == "text":
                        message_text = message["text"]["body"]
                        logger.info(f"   Content: {message_text}")
                        
                        # Check for admin commands (new secure system)
                        if db and message_text.startswith("/admin:"):
                            admin_response = await admin.handle_admin_whatsapp_command(
                                from_number, message_text, db
                            )
                            
                            if admin_response:
                                await send_whatsapp_message(from_number, admin_response)
                                return JSONResponse(content={"status": "ok"})
                        
                        # Get or create user
                        user_data, is_new_user = await get_or_create_user(from_number)
                        
                        # Send welcome message to new users BEFORE AI processing
                        if is_new_user:
                            await send_whatsapp_message(from_number, WELCOME_MESSAGE)
                            await add_message_to_history(from_number, "assistant", WELCOME_MESSAGE)
                            logger.info(f"üëã Sent welcome message to new user: {from_number}")
                        
                        # Process with AI
                        await process_message_with_ai(from_number, message_text, user_data, is_new_user)
                    
                    else:
                        await send_whatsapp_message(
                            from_number,
                            "◊ê◊†◊ô ◊ô◊õ◊ï◊ú ◊ú◊î◊í◊ô◊ë ◊®◊ß ◊ú◊î◊ï◊ì◊¢◊ï◊™ ◊ò◊ß◊°◊ò ◊õ◊®◊í◊¢ üìù"
                        )
        
        return JSONResponse(content={"status": "ok"})
    
    except Exception as e:
        logger.error(f"‚ùå Error processing webhook: {str(e)}", exc_info=True)
        return JSONResponse(content={"status": "error", "message": str(e)})


async def process_message_with_ai(phone_number: str, message: str, user_data: dict, is_new_user: bool = False):
    """Process user message with Gemini AI"""
    try:
        if not GEMINI_API_KEY:
            # Fallback without AI
            response = f"◊ß◊ô◊ë◊ú◊™◊ô: {message}\n(AI ◊ú◊ê ◊û◊ï◊§◊¢◊ú)"
            await send_whatsapp_message(phone_number, response)
            return
        
        # Add user message to history
        await add_message_to_history(phone_number, "user", message)
        
        # If new user, refresh user_data to include the welcome message we just added
        if is_new_user:
            user_data, _ = await get_or_create_user(phone_number)
        
        # Get current context
        now = datetime.utcnow()
        current_timestamp = now.strftime("%Y-%m-%d %H:%M:%S UTC")
        current_day_of_week = now.strftime("%A")
        
        # Build system prompt with context
        system_prompt = SYSTEM_PROMPT.format(
            current_timestamp=current_timestamp,
            current_day_of_week=current_day_of_week
        )
        
        # Build conversation history
        chat_history = user_data.get("chat_history", [])
        conversation = []
        
        for msg in chat_history[-4:]:  # Last 4 messages
            if msg["role"] == "user":
                conversation.append({"role": "user", "parts": [msg["content"]]})
            elif msg["role"] == "assistant":
                conversation.append({"role": "model", "parts": [msg["content"]]})
        
        # Initialize Gemini client with new SDK
        client = genai.Client(api_key=GEMINI_API_KEY)
        
        # Create config with tools
        config = types.GenerateContentConfig(
            system_instruction=system_prompt,
            tools=[get_function_tool()],
            temperature=0.7
        )
        
        # Build message history for new API
        history = []
        for msg in conversation[:-1]:
            history.append(types.Content(
                role=msg["role"],
                parts=[types.Part(text=msg["parts"][0])]
            ))
        
        # Add current message
        history.append(types.Content(
            role="user",
            parts=[types.Part(text=message)]
        ))
        
        # Generate response with function calling
        # Using Gemini 2.5 Flash - latest model
        response = client.models.generate_content(
            model="gemini-2.0-flash-exp",
            contents=history,
            config=config
        )
        
        # Check for function calls
        if response.candidates[0].content.parts:
            for part in response.candidates[0].content.parts:
                if hasattr(part, 'function_call') and part.function_call:
                    function_call = part.function_call
                    function_name = function_call.name
                    function_args = dict(function_call.args)
                    
                    # Convert RepeatedComposite (protobuf) to list for JSON serialization
                    for key, value in function_args.items():
                        if hasattr(value, '__iter__') and not isinstance(value, (str, dict)):
                            function_args[key] = list(value)
                    
                    logger.info(f"ü§ñ AI called function: {function_name}")
                    logger.info(f"   Args: {json.dumps(function_args, ensure_ascii=False)}")
                    
                    # Execute function
                    result = await execute_function_call(function_name, function_args, phone_number)
                    
                    # Send function result back to AI for continuation
                    history.append(response.candidates[0].content)
                    history.append(types.Content(
                        role="user",
                        parts=[types.Part(
                            function_response=types.FunctionResponse(
                                name=function_name,
                                response={"result": result}
                            )
                        )]
                    ))
                    
                    # Get final response from AI
                    response = client.models.generate_content(
                        model="gemini-2.0-flash-exp",
                        contents=history,
                        config=config
                    )
        
        # Get final text response
        ai_response = response.text
        logger.info(f"ü§ñ AI response: {ai_response[:100]}...")
        
        # Send to user
        await send_whatsapp_message(phone_number, ai_response)
        
        # Add to history
        await add_message_to_history(phone_number, "assistant", ai_response)
    
    except Exception as e:
        logger.error(f"‚ùå Error in AI processing: {str(e)}", exc_info=True)
        error_msg = "◊°◊ú◊ô◊ó◊î, ◊†◊™◊ß◊ú◊™◊ô ◊ë◊ë◊¢◊ô◊î. ◊ê◊†◊ê ◊†◊°◊î ◊©◊ï◊ë. üôè"
        await send_whatsapp_message(phone_number, error_msg)


async def execute_function_call(function_name: str, function_args: dict, phone_number: str) -> dict:
    """Execute AI function call"""
    try:
        if function_name == "update_user_records":
            role = function_args.get("role")
            
            # Build role data (origin is always ◊í◊ë◊®◊¢◊ù)
            role_data = {}
            if role == "driver":
                role_data = {
                    "origin": "◊í◊ë◊®◊¢◊ù",  # Always Gvar'am
                    "destination": function_args.get("destination"),
                    "days": function_args.get("days", []),
                    "departure_time": function_args.get("departure_time"),
                    "return_time": function_args.get("return_time"),
                    "available_seats": function_args.get("available_seats", 3),  # Default 3 seats
                    "notes": function_args.get("notes", "")
                }
            elif role == "hitchhiker":
                role_data = {
                    "origin": "◊í◊ë◊®◊¢◊ù",  # Always Gvar'am
                    "destination": function_args.get("destination"),
                    "travel_date": function_args.get("travel_date"),
                    "departure_time": function_args.get("departure_time"),
                    "flexibility": function_args.get("flexibility", "flexible"),
                    "notes": function_args.get("notes", "")
                }
            
            # Update database
            success = await update_user_role_and_data(phone_number, role, role_data)
            
            if not success:
                return {"success": False, "message": "Failed to update user records"}
            
            # Try to find matches
            if role == "hitchhiker":
                drivers = await get_drivers_by_route(
                    origin="◊í◊ë◊®◊¢◊ù",
                    destination=function_args.get("destination")
                )
                return {
                    "success": True,
                    "message": f"User registered as {role}",
                    "role": role,
                    "data": role_data,
                    "matches_found": len(drivers),
                    "drivers": drivers[:3]  # Return top 3 matches
                }
            else:  # driver
                hitchhikers = await get_hitchhiker_requests(
                    destination=function_args.get("destination")
                )
                return {
                    "success": True,
                    "message": f"User registered as {role}",
                    "role": role,
                    "data": role_data,
                    "matches_found": len(hitchhikers),
                    "hitchhikers": hitchhikers[:3]  # Return top 3 matches
                }
        
        return {"success": False, "message": f"Unknown function: {function_name}"}
    
    except Exception as e:
        logger.error(f"‚ùå Error executing function: {str(e)}")
        return {"success": False, "message": str(e)}


# Database functions (same as Step 2)
async def get_or_create_user(phone_number: str) -> tuple[dict, bool]:
    """Get user from Firestore or create if doesn't exist
    
    Returns:
        tuple: (user_data, is_new_user)
    """
    if not db:
        return {"phone_number": phone_number, "chat_history": []}, False
    
    try:
        doc_ref = db.collection("users").document(phone_number)
        doc = doc_ref.get()
        
        if doc.exists:
            return doc.to_dict(), False
        else:
            user_data = {
                "phone_number": phone_number,
                "role": None,
                "notification_level": "all",
                "driver_data": {},
                "hitchhiker_data": {},
                "created_at": datetime.utcnow().isoformat(),
                "last_seen": datetime.utcnow().isoformat(),
                "chat_history": []
            }
            doc_ref.set(user_data)
            logger.info(f"‚úÖ Created new user: {phone_number}")
            return user_data, True
    except Exception as e:
        logger.error(f"‚ùå Error getting user: {str(e)}")
        # When DB fails, don't treat as new user to avoid spam
        return {"phone_number": phone_number, "chat_history": []}, False


async def add_message_to_history(phone_number: str, role: str, content: str) -> bool:
    """Add message to chat history (keep last 5)"""
    if not db:
        return False
    
    try:
        doc_ref = db.collection("users").document(phone_number)
        doc = doc_ref.get()
        
        if not doc.exists:
            return False
        
        user_data = doc.to_dict()
        chat_history = user_data.get("chat_history", [])
        
        chat_history.append({
            "role": role,
            "content": content,
            "timestamp": datetime.utcnow().isoformat()
        })
        
        chat_history = chat_history[-5:]
        
        doc_ref.update({
            "chat_history": chat_history,
            "last_seen": datetime.utcnow().isoformat()
        })
        
        return True
    except Exception as e:
        logger.error(f"‚ùå Error adding to history: {str(e)}")
        return False


async def update_user_role_and_data(phone_number: str, role: str, role_data: dict) -> bool:
    """Update user role and data"""
    if not db:
        return False
    
    try:
        doc_ref = db.collection("users").document(phone_number)
        
        update_data = {
            "role": role,
            "last_seen": datetime.utcnow().isoformat()
        }
        
        if role == "driver":
            update_data["driver_data"] = role_data
        elif role == "hitchhiker":
            update_data["hitchhiker_data"] = role_data
        
        doc_ref.set(update_data, merge=True)
        logger.info(f"‚úÖ Updated {phone_number} as {role}")
        
        return True
    except Exception as e:
        logger.error(f"‚ùå Error updating role: {str(e)}")
        return False


async def get_drivers_by_route(origin: str = None, destination: str = None) -> list:
    """Search for drivers matching specific route"""
    if not db:
        return []
    
    try:
        # Get all drivers
        docs = db.collection("users").where("role", "==", "driver").stream()
        
        drivers = []
        for doc in docs:
            driver_data = doc.to_dict()
            driver_info = driver_data.get("driver_data", {})
            
            # Filter by destination (origin is always ◊í◊ë◊®◊¢◊ù)
            if destination and driver_info.get("destination"):
                if destination.lower() not in driver_info["destination"].lower():
                    continue
            
            drivers.append({
                "phone_number": driver_data.get("phone_number"),
                "destination": driver_info.get("destination"),
                "days": driver_info.get("days", []),
                "departure_time": driver_info.get("departure_time"),
                "return_time": driver_info.get("return_time"),
                "available_seats": driver_info.get("available_seats", 3)
            })
        
        logger.info(f"üöó Found {len(drivers)} matching drivers")
        return drivers
    
    except Exception as e:
        logger.error(f"‚ùå Error searching for drivers: {str(e)}")
        return []


async def get_hitchhiker_requests(destination: str = None) -> list:
    """Get hitchhiker requests, optionally filtered by destination"""
    if not db:
        return []
    
    try:
        # Get all hitchhikers
        docs = db.collection("users").where("role", "==", "hitchhiker").stream()
        
        hitchhikers = []
        for doc in docs:
            hitchhiker_data = doc.to_dict()
            hitchhiker_info = hitchhiker_data.get("hitchhiker_data", {})
            
            # Filter by destination
            if destination and hitchhiker_info.get("destination"):
                if destination.lower() not in hitchhiker_info["destination"].lower():
                    continue
            
            hitchhikers.append({
                "phone_number": hitchhiker_data.get("phone_number"),
                "destination": hitchhiker_info.get("destination"),
                "travel_date": hitchhiker_info.get("travel_date"),
                "departure_time": hitchhiker_info.get("departure_time"),
                "flexibility": hitchhiker_info.get("flexibility", "flexible")
            })
        
        logger.info(f"üö∂ Found {len(hitchhikers)} matching hitchhikers")
        return hitchhikers
    
    except Exception as e:
        logger.error(f"‚ùå Error searching for hitchhikers: {str(e)}")
        return []


async def send_whatsapp_message(phone_number: str, message: str) -> bool:
    """Send WhatsApp message"""
    try:
        if not WHATSAPP_TOKEN or not WHATSAPP_PHONE_NUMBER_ID:
            return False
        
        headers = {
            "Authorization": f"Bearer {WHATSAPP_TOKEN}",
            "Content-Type": "application/json"
        }
        
        payload = {
            "messaging_product": "whatsapp",
            "to": phone_number,
            "type": "text",
            "text": {"body": message}
        }
        
        response = requests.post(WHATSAPP_API_URL, headers=headers, json=payload)
        response.raise_for_status()
        
        logger.info(f"‚úÖ Message sent to {phone_number}")
        return True
    
    except Exception as e:
        logger.error(f"‚ùå Error sending message: {str(e)}")
        return False


@app.get("/users", dependencies=[Depends(admin.verify_admin_token)])
async def list_users():
    """List all users in database (requires admin token)"""
    if not db:
        return {"error": "Database not available"}
    
    try:
        users = []
        docs = db.collection("users").stream()
        
        for doc in docs:
            user_data = doc.to_dict()
            users.append({
                "phone_number": user_data.get("phone_number"),
                "role": user_data.get("role"),
                "message_count": len(user_data.get("chat_history", [])),
                "last_seen": user_data.get("last_seen"),
                "driver_data": user_data.get("driver_data", {}),
                "hitchhiker_data": user_data.get("hitchhiker_data", {})
            })
        
        return {"users": users, "count": len(users)}
    
    except Exception as e:
        logger.error(f"Error listing users: {str(e)}")
        return {"error": str(e)}


@app.get("/user/{phone_number}", dependencies=[Depends(admin.verify_admin_token)])
async def get_user_details(phone_number: str):
    """Get specific user data (requires admin token)"""
    if not db:
        return {"error": "Database not available"}
    
    try:
        doc_ref = db.collection("users").document(phone_number)
        doc = doc_ref.get()
        
        if doc.exists:
            return doc.to_dict()
        else:
            return {"error": "User not found"}
    
    except Exception as e:
        logger.error(f"Error getting user: {str(e)}")
        return {"error": str(e)}


if __name__ == "__main__":
    logger.info("üöÄ Starting AI-Powered Hitchhiking Bot (Step 3)")
    logger.info(f"   VERIFY_TOKEN: {'‚úÖ' if VERIFY_TOKEN else '‚ùå'}")
    logger.info(f"   WHATSAPP_TOKEN: {'‚úÖ' if WHATSAPP_TOKEN else '‚ùå'}")
    logger.info(f"   GEMINI_API_KEY: {'‚úÖ' if GEMINI_API_KEY else '‚ùå'}")
    
    port = int(os.getenv("PORT", 8080))
    uvicorn.run(app, host="0.0.0.0", port=port)

